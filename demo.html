<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Upright - Ëá™Âä®ÈÄèËßÜÁü´Ê≠£</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #888;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ccc;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-tooltip {
            display: block;
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 4px;
        }

        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .option {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .option select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .option-label {
            display: flex;
            flex-direction: column;
        }

        .option-label .en {
            font-size: 0.75rem;
            color: #888;
        }

        .status {
            text-align: center;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status .label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 4px;
        }

        .status .text {
            font-size: 1rem;
        }

        .status.loading .text {
            color: #ffc107;
        }

        .status.success .text {
            color: #4caf50;
        }

        .status.error .text {
            color: #f44336;
        }

        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .image-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .image-box .title {
            padding: 12px 16px;
            font-size: 0.85rem;
            color: #aaa;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .image-box .size {
            font-size: 0.75rem;
            color: #666;
        }

        .image-box .content {
            position: relative;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
        }

        .image-box img {
            max-width: 100%;
            max-height: 60vh;
            display: block;
        }

        .placeholder {
            color: #555;
            font-size: 0.9rem;
            text-align: center;
            line-height: 1.5;
        }

        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 20px;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .drop-zone .icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }

        .drop-zone .text {
            color: #888;
        }

        .drop-zone .text-en {
            font-size: 0.8rem;
            color: #666;
            margin-top: 4px;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            .btn {
                padding: 10px 18px;
                font-size: 0.9rem;
            }

            .option {
                padding: 8px 12px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Auto Upright</h1>
            <p class="subtitle">Ëá™Âä®ÈÄèËßÜÁü´Ê≠£ ¬∑ Êô∫ËÉΩÂéªÈªëËæπ | Automatic Perspective Correction ¬∑ Smart Cropping</p>
        </header>

        <!-- ÊãñÊãΩ‰∏ä‰º†Âå∫ / Drag & Drop Zone -->
        <div class="drop-zone" id="dropZone">
            <div class="icon">üì∑</div>
            <div class="text">ÊãñÊãΩÂõæÁâáÂà∞ËøôÈáåÔºåÊàñÁÇπÂáª‰∏ä‰º†</div>
            <div class="text-en">Drag and drop image here, or click to upload</div>
        </div>
        <input type="file" id="fileInput" accept="image/*" class="hidden">

        <!-- ÊéßÂà∂ÊåâÈíÆ / Control Buttons -->
        <div class="controls">
            <button class="btn btn-primary" id="btnUpload">
                üìÅ ÈÄâÊã©ÂõæÁâá / Select Image
                <span class="btn-tooltip">Click to browse and select an image file</span>
            </button>
            <button class="btn btn-secondary" id="btnProcess" disabled>
                ‚ö° ÂºÄÂßãÁü´Ê≠£ / Start Correction
                <span class="btn-tooltip">Process the image to straighten perspective</span>
            </button>
            <button class="btn btn-secondary" id="btnDownload" disabled>
                üíæ ‰∏ãËΩΩÁªìÊûú / Download Result
                <span class="btn-tooltip">Save the corrected image to your device</span>
            </button>
        </div>

        <!-- ÈÄâÈ°π / Options -->
        <div class="options">
            <label class="option">
                <span class="option-label">
                    <span>Ê®°Âºè / Mode</span>
                </span>
                <select id="modeSelect">
                    <option value="auto">Auto Ëá™Âä®</option>
                    <option value="vertical">Vertical ‰ªÖÂûÇÁõ¥</option>
                    <option value="full">Full ÂÆåÊï¥2ÁÇπ</option>
                </select>
            </label>
            <label class="option">
                <input type="checkbox" id="autoCropCheck" checked>
                <span class="option-label">
                    <span>Êô∫ËÉΩË£ÅÂàáÈªëËæπ</span>
                    <span class="en">Smart Crop Black Borders</span>
                </span>
            </label>
            <label class="option">
                <input type="checkbox" id="blackCornersCheck" checked>
                <span class="option-label">
                    <span>ÈªëËâ≤Â°´ÂÖÖËæπËßí</span>
                    <span class="en">Black Fill Corners</span>
                </span>
            </label>
        </div>

        <!-- Áä∂ÊÄÅ / Status -->
        <div class="status" id="status">
            <div class="label">Áä∂ÊÄÅ / Status</div>
            <div class="text" id="statusText">Á≠âÂæÖÂä†ËΩΩ OpenCV.js... | Loading OpenCV.js...</div>
        </div>

        <!-- ÂõæÁâáÂ±ïÁ§∫ / Image Display -->
        <div class="gallery">
            <div class="image-box">
                <div class="title">
                    <span>ÂéüÂõæ / Original</span>
                    <span class="size" id="origSize"></span>
                </div>
                <div class="content">
                    <img id="origImg" class="hidden">
                    <div class="placeholder" id="origPlaceholder">
                        ‰∏ä‰º†ÂõæÁâáÂêéÊòæÁ§∫<br>
                        <span style="font-size: 0.8rem; color: #444;">Image will appear after upload</span>
                    </div>
                </div>
            </div>
            <div class="image-box">
                <div class="title">
                    <span>Áü´Ê≠£Âêé / Corrected</span>
                    <span class="size" id="outSize"></span>
                </div>
                <div class="content">
                    <img id="outImg" class="hidden">
                    <div class="placeholder" id="outPlaceholder">
                        Â§ÑÁêÜÂêéÊòæÁ§∫<br>
                        <span style="font-size: 0.8rem; color: #444;">Result will appear after processing</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

    <script>
        // ============================================
        // Auto Upright - Inline Library
        // ============================================

        // --- Math Helpers ---
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

        const ang180 = (rad) => {
            let d = (rad * 180) / Math.PI;
            d = ((d % 180) + 180) % 180;
            return d;
        };

        const line2 = (x1, y1, x2, y2) => {
            const a = y1 - y2, b = x2 - x1, c = x1 * y2 - x2 * y1;
            return [a, b, c];
        };

        const dist = (l, x, y) => {
            const [a, b, c] = l;
            const d = Math.hypot(a, b);
            return d < 1e-12 ? 1e9 : Math.abs(a * x + b * y + c) / d;
        };

        const inter = (l1, l2) => {
            const [a1, b1, c1] = l1, [a2, b2, c2] = l2;
            const det = a1 * b2 - a2 * b1;
            if (Math.abs(det) < 1e-12) return null;
            return [(b1 * c2 - b2 * c1) / det, (c1 * a2 - c2 * a1) / det];
        };

        const normL = (l) => {
            let [a, b, c] = l;
            const s = Math.hypot(a, b) || 1;
            return [a / s, b / s, c / s];
        };

        const mul3 = (A, B) => {
            const C = new Array(9).fill(0);
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    C[r * 3 + c] = A[r * 3] * B[c] + A[r * 3 + 1] * B[c + 3] + A[r * 3 + 2] * B[c + 6];
                }
            }
            return C;
        };

        const appH = (H, x, y) => {
            const X = H[0] * x + H[1] * y + H[2],
                Y = H[3] * x + H[4] * y + H[5],
                W = H[6] * x + H[7] * y + H[8];
            return [X, Y, W];
        };

        function rotC(deg, w, h) {
            const t = (deg * Math.PI) / 180, ct = Math.cos(t), st = Math.sin(t);
            const R = [ct, -st, 0, st, ct, 0, 0, 0, 1];
            const cx = w / 2, cy = h / 2;
            const T1 = [1, 0, -cx, 0, 1, -cy, 0, 0, 1], T2 = [1, 0, cx, 0, 1, cy, 0, 0, 1];
            return mul3(T2, mul3(R, T1));
        }

        function onePointVerticalH(vp, w, h) {
            const cx = w / 2, cy = h / 2;
            const vx = vp[0] - cx;
            const vy = vp[1] - cy;
            if (Math.abs(vy) > 100000) return [1, 0, 0, 0, 1, 0, 0, 0, 1];
            const hy = -1.0 / vy;
            const P_center = [1, 0, 0, 0, 1, 0, 0, hy, 1];
            const T1 = [1, 0, -cx, 0, 1, -cy, 0, 0, 1];
            const T2 = [1, 0, cx, 0, 1, cy, 0, 0, 1];
            return mul3(T2, mul3(P_center, T1));
        }

        function makeRng(seed) {
            let t = seed >>> 0;
            return () => {
                t += 0x6d2b79f5;
                let x = t;
                x = Math.imul(x ^ (x >>> 15), 1 | x);
                x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
                return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
            };
        }

        function ransacVP(lines, rng, width, height) {
            if (lines.length < 2) return null;
            const n = lines.length;
            const iters = Math.min(500, n * n);
            let best = { x: 0, y: 0, count: 0, score: 0 };

            for (let k = 0; k < iters; k++) {
                const i = (rng() * n) | 0;
                let j = (rng() * n) | 0;
                if (i === j) j = (j + 1) % n;

                const p = inter(lines[i], lines[j]);
                if (!p) continue;
                const [px, py] = p;
                if (!Number.isFinite(px) || !Number.isFinite(py)) continue;

                let count = 0;
                let sumDist = 0;
                const threshold = Math.max(width, height) * 0.02;

                for (let m = 0; m < n; m++) {
                    const d = dist(lines[m], px, py);
                    if (d < threshold) {
                        count++;
                        sumDist += d;
                    }
                }

                const isInside = (px > 0 && px < width && py > 0 && py < height);
                if (isInside) continue;

                const score = count * 1000 - sumDist;
                if (score > best.score) {
                    best = { x: px, y: py, count, score };
                }
            }

            if (best.count < Math.max(4, n * 0.15)) return null;
            return best;
        }

        function autoCropToLargestInscribedRect(dst, maskDst, cv) {
            const rows = maskDst.rows;
            const cols = maskDst.cols;
            const data = maskDst.data;

            const heights = new Uint16Array(rows * cols);
            for (let c = 0; c < cols; c++) {
                heights[c] = data[c] > 127 ? 1 : 0;
            }
            for (let r = 1; r < rows; r++) {
                const rowOffset = r * cols;
                const prevRowOffset = (r - 1) * cols;
                for (let c = 0; c < cols; c++) {
                    if (data[rowOffset + c] > 127) {
                        heights[rowOffset + c] = heights[prevRowOffset + c] + 1;
                    } else {
                        heights[rowOffset + c] = 0;
                    }
                }
            }

            let bestArea = 0;
            let bestRect = { x: 0, y: 0, w: 0, h: 0 };

            const largestRectInHistogram = (row) => {
                const stack = [];
                let maxArea = 0;
                let maxRect = null;
                const rowOffset = row * cols;

                for (let i = 0; i <= cols; i++) {
                    const h = (i === cols) ? 0 : heights[rowOffset + i];
                    let startIdx = i;

                    while (stack.length > 0 && stack[stack.length - 1].h > h) {
                        const top = stack.pop();
                        const width = i - top.idx;
                        const area = top.h * width;

                        if (area > maxArea) {
                            maxArea = area;
                            maxRect = { x: top.idx, y: row - top.h + 1, w: width, h: top.h };
                        }
                        startIdx = top.idx;
                    }
                    stack.push({ idx: startIdx, h: h });
                }
                return { area: maxArea, rect: maxRect };
            };

            for (let r = 0; r < rows; r++) {
                const result = largestRectInHistogram(r);
                if (result.area > bestArea && result.rect) {
                    bestArea = result.area;
                    bestRect = result.rect;
                }
            }

            if (bestArea > 100 && bestRect.w > 10 && bestRect.h > 10) {
                try {
                    const rect = new cv.Rect(bestRect.x, bestRect.y, bestRect.w, bestRect.h);
                    const roi = dst.roi(rect);
                    const cropped = roi.clone();
                    roi.delete();
                    return cropped;
                } catch (e) {
                    console.warn("Crop ROI failed", e);
                    return null;
                }
            }
            return null;
        }

        // --- Main autoUpright function ---
        async function autoUpright(imageSrc, options = {}) {
            const { autoCrop = true } = options;

            return new Promise((resolve) => {
                const cv = window.cv;
                if (!cv || !cv.Mat) {
                    resolve({ success: false, error: "OpenCV not loaded" });
                    return;
                }

                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = imageSrc;

                img.onload = async () => {
                    let src = null, gray = null, blur = null, edges = null, lines = null;
                    let srcFull = null, dst = null, maskSrc = null, maskDst = null;

                    try {
                        const W = img.width;
                        const H = img.height;

                        const analysisScale = Math.min(1, 1000 / Math.max(W, H));
                        const aw = Math.round(W * analysisScale);
                        const ah = Math.round(H * analysisScale);

                        const canvas = document.createElement('canvas');
                        canvas.width = aw;
                        canvas.height = ah;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        if (!ctx) throw new Error("Context failed");
                        ctx.drawImage(img, 0, 0, aw, ah);

                        src = cv.imread(canvas);
                        gray = new cv.Mat();
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                        blur = new cv.Mat();
                        cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 1.5, 1.5, cv.BORDER_DEFAULT);

                        edges = new cv.Mat();
                        cv.Canny(blur, edges, 50, 150);

                        lines = new cv.Mat();
                        const minLineLen = Math.max(aw, ah) * 0.08;
                        const maxLineGap = Math.max(aw, ah) * 0.03;
                        cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 50, minLineLen, maxLineGap);

                        const detectedLines = [];
                        for (let i = 0; i < lines.rows; i++) {
                            const x1 = lines.data32S[i * 4];
                            const y1 = lines.data32S[i * 4 + 1];
                            const x2 = lines.data32S[i * 4 + 2];
                            const y2 = lines.data32S[i * 4 + 3];
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const len = Math.hypot(dx, dy);
                            const angle = ang180(Math.atan2(dy, dx));
                            detectedLines.push({ x1, y1, x2, y2, angle, len });
                        }

                        const verticalTolerance = 25;
                        const verticalLines = detectedLines.filter(l => Math.abs(l.angle - 90) < verticalTolerance);

                        if (verticalLines.length < 4) {
                            console.warn("Not enough vertical lines found. Skipping correction.");
                            resolve({ success: true, image: imageSrc });
                            return;
                        }

                        const lineEqs = verticalLines.map(l => normL(line2(l.x1, l.y1, l.x2, l.y2)));

                        const rng = makeRng(W * H + verticalLines.length);
                        const vp = ransacVP(lineEqs, rng, aw, ah);

                        let FinalH = [1, 0, 0, 0, 1, 0, 0, 0, 1];

                        if (vp) {
                            const cx = aw / 2;
                            const cy = ah / 2;
                            const vx = vp.x - cx;
                            const vy = vp.y - cy;

                            const vpAngle = Math.atan2(vy, vx) * 180 / Math.PI;

                            let rotateDeg = 0;
                            if (vy < 0) {
                                rotateDeg = -90 - vpAngle;
                            } else {
                                rotateDeg = 90 - vpAngle;
                            }

                            if (Math.abs(rotateDeg) > 15) {
                                rotateDeg = clamp(rotateDeg, -15, 15);
                            }

                            const R = rotC(rotateDeg, aw, ah);
                            const vpRot = appH(R, vp.x, vp.y);
                            const vpx_new = vpRot[0] / vpRot[2];
                            const vpy_new = vpRot[1] / vpRot[2];

                            let H_persp = [1, 0, 0, 0, 1, 0, 0, 0, 1];

                            if (Math.abs(vpy_new) > ah * 1.5) {
                                H_persp = onePointVerticalH([vpx_new, vpy_new], aw, ah);
                            }

                            FinalH = mul3(H_persp, R);
                        } else {
                            const avgAng = verticalLines.reduce((s, l) => s + l.angle, 0) / verticalLines.length;
                            const rotNeeded = 90 - avgAng;
                            if (Math.abs(rotNeeded) < 10) {
                                FinalH = rotC(rotNeeded, aw, ah);
                            }
                        }

                        const Sdown = [analysisScale, 0, 0, 0, analysisScale, 0, 0, 0, 1];
                        const Sup = [1 / analysisScale, 0, 0, 0, 1 / analysisScale, 0, 0, 0, 1];
                        const FullH = mul3(Sup, mul3(FinalH, Sdown));

                        const pts = [[0, 0], [W, 0], [W, H], [0, H]];
                        const projPts = pts.map(p => {
                            const res = appH(FullH, p[0], p[1]);
                            return [res[0] / res[2], res[1] / res[2]];
                        });

                        const xs = projPts.map(p => p[0]);
                        const ys = projPts.map(p => p[1]);
                        const bbW = Math.max(...xs) - Math.min(...xs);
                        const bbH = Math.max(...ys) - Math.min(...ys);

                        if (bbW * bbH > (W * H * 3.0) || bbW < W * 0.5) {
                            resolve({ success: true, image: imageSrc });
                            return;
                        }

                        const minX = Math.min(...xs);
                        const minY = Math.min(...ys);

                        const T = [1, 0, -minX, 0, 1, -minY, 0, 0, 1];
                        const FinalMatrix = mul3(T, FullH);

                        const finalW = Math.round(bbW);
                        const finalH = Math.round(bbH);

                        srcFull = cv.imread(img);
                        dst = new cv.Mat();
                        const M = cv.matFromArray(3, 3, cv.CV_64F, FinalMatrix);

                        cv.warpPerspective(srcFull, dst, M, new cv.Size(finalW, finalH), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0, 0, 0, 0));

                        if (autoCrop) {
                            maskSrc = new cv.Mat(srcFull.rows, srcFull.cols, cv.CV_8UC1, new cv.Scalar(255));
                            maskDst = new cv.Mat();
                            cv.warpPerspective(maskSrc, maskDst, M, new cv.Size(finalW, finalH), cv.INTER_NEAREST, cv.BORDER_CONSTANT, new cv.Scalar(0));

                            const cropped = autoCropToLargestInscribedRect(dst, maskDst, cv);
                            if (cropped) {
                                dst.delete();
                                dst = cropped;
                            }
                        }

                        const tempCanvas = document.createElement('canvas');
                        cv.imshow(tempCanvas, dst);
                        resolve({ success: true, image: tempCanvas.toDataURL('image/jpeg', 0.95) });

                        M.delete();
                        srcFull.delete();
                        dst.delete();
                        if (maskSrc) maskSrc.delete();
                        if (maskDst) maskDst.delete();

                    } catch (e) {
                        console.error("OpenCV Error", e);
                        resolve({ success: false, error: String(e) });
                    } finally {
                        if (src) src.delete();
                        if (gray) gray.delete();
                        if (blur) blur.delete();
                        if (edges) edges.delete();
                        if (lines) lines.delete();
                    }
                };
                img.onerror = () => resolve({ success: false, error: "Image load failed" });
            });
        }

        // ============================================
        // UI Logic
        // ============================================

        const $ = id => document.getElementById(id);
        let cvReady = false;
        let currentFile = null;
        let resultDataUrl = null;

        function setStatus(text, type = '') {
            $('status').className = 'status ' + type;
            $('statusText').textContent = text;
        }

        // Á≠âÂæÖ OpenCV Âä†ËΩΩ / Wait for OpenCV to load
        function waitForOpenCV() {
            return new Promise(resolve => {
                const check = () => {
                    if (window.cv && window.cv.Mat) { cvReady = true; resolve(); }
                    else setTimeout(check, 100);
                };
                check();
            });
        }

        waitForOpenCV().then(() => {
            setStatus('OpenCV Â∑≤Â∞±Áª™ÔºåËØ∑‰∏ä‰º†ÂõæÁâá | OpenCV ready, please upload an image', 'success');
        });

        // ÊãñÊãΩ‰∏ä‰º† / Drag and drop upload
        const dropZone = $('dropZone');
        dropZone.addEventListener('click', () => $('fileInput').click());
        dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('dragover'); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); });

        $('fileInput').addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
        $('btnUpload').addEventListener('click', () => $('fileInput').click());
        $('btnProcess').addEventListener('click', processImage);
        $('btnDownload').addEventListener('click', downloadResult);

        function handleFile(file) {
            currentFile = file;
            const url = URL.createObjectURL(file);
            const img = $('origImg');
            img.onload = () => {
                $('origPlaceholder').classList.add('hidden');
                img.classList.remove('hidden');
                $('origSize').textContent = `${img.naturalWidth} √ó ${img.naturalHeight}`;
                $('btnProcess').disabled = !cvReady;
                // Ê∏ÖÁ©∫‰πãÂâçÁöÑÁªìÊûú / Clear previous result
                $('outImg').classList.add('hidden');
                $('outPlaceholder').classList.remove('hidden');
                $('outSize').textContent = '';
                $('btnDownload').disabled = true;
                resultDataUrl = null;
                setStatus('ÂõæÁâáÂ∑≤Âä†ËΩΩÔºåÁÇπÂáª"ÂºÄÂßãÁü´Ê≠£"Â§ÑÁêÜ | Image loaded, click "Start Correction" to process', 'success');
            };
            img.src = url;
        }

        async function processImage() {
            if (!cvReady || !currentFile) return;

            setStatus('Ê≠£Âú®Â§ÑÁêÜ... | Processing...', 'loading');
            $('btnProcess').disabled = true;

            try {
                const autoCropEnabled = $('autoCropCheck').checked;

                // Â∞ÜÊñá‰ª∂ËΩ¨‰∏∫ dataURL / Convert file to dataURL
                const dataUrl = await fileToDataUrl(currentFile);

                const result = await autoUpright(dataUrl, {
                    autoCrop: autoCropEnabled
                });

                if (result.success) {
                    resultDataUrl = result.image;
                    showResult(resultDataUrl);
                    setStatus('Â§ÑÁêÜÂÆåÊàê | Processing complete', 'success');
                } else {
                    setStatus('Â§ÑÁêÜÂ§±Ë¥• | Processing failed: ' + (result.error || 'Êú™Áü•ÈîôËØØ Unknown error'), 'error');
                }
            } catch (err) {
                console.error(err);
                setStatus('Â§ÑÁêÜÂ§±Ë¥• | Processing failed: ' + err.message, 'error');
            }

            $('btnProcess').disabled = false;
        }

        function showResult(dataUrl) {
            const img = $('outImg');
            img.onload = () => {
                $('outPlaceholder').classList.add('hidden');
                img.classList.remove('hidden');
                $('outSize').textContent = `${img.naturalWidth} √ó ${img.naturalHeight}`;
                $('btnDownload').disabled = false;
            };
            img.src = dataUrl;
        }

        function downloadResult() {
            if (!resultDataUrl) return;
            const a = document.createElement('a');
            a.href = resultDataUrl;
            a.download = 'upright_' + (currentFile?.name?.replace(/\.[^.]+$/, '.jpg') || 'image.jpg');
            a.click();
        }

        function fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
    </script>
</body>

</html>
